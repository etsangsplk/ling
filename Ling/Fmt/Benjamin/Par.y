-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Ling.Fmt.Benjamin.Par where
import Ling.Fmt.Benjamin.Abs
import Ling.Fmt.Benjamin.Lex
import Ling.ErrM

}

%name pProgram Program
%name pDec Dec
%name pAssertion Assertion
%name pConName ConName
%name pListConName ListConName
%name pOptSig OptSig
%name pListDec ListDec
%name pVarDec VarDec
%name pChanDec ChanDec
%name pListChanDec ListChanDec
%name pBranch Branch
%name pListBranch ListBranch
%name pLiteral Literal
%name pATerm ATerm
%name pListATerm ListATerm
%name pTerm3 Term3
%name pTerm2 Term2
%name pTerm1 Term1
%name pTerm Term
%name pProc1 Proc1
%name pProc Proc
%name pListProc ListProc
%name pReplKind ReplKind
%name pWithIndex WithIndex
%name pAct Act
%name pASession ASession
%name pOptAs OptAs
%name pOptSplit OptSplit
%name pTopCPatt TopCPatt
%name pCPatt CPatt
%name pListCPatt ListCPatt
%name pOptSession OptSession
%name pRSession RSession
%name pListRSession ListRSession
%name pOptRepl OptRepl
%name pCSession CSession
%name pAllocTerm AllocTerm
%name pListAllocTerm ListAllocTerm
%name pNewSig NewSig
%name pNewPatt NewPatt
%name pNewAlloc NewAlloc
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '!' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '**' { PT _ (TS _ 4) }
  ',' { PT _ (TS _ 5) }
  '->' { PT _ (TS _ 6) }
  '-o' { PT _ (TS _ 7) }
  '.' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  ':*' { PT _ (TS _ 10) }
  ':]' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '<' { PT _ (TS _ 13) }
  '<-' { PT _ (TS _ 14) }
  '<=' { PT _ (TS _ 15) }
  '=' { PT _ (TS _ 16) }
  '>' { PT _ (TS _ 17) }
  '?' { PT _ (TS _ 18) }
  '@' { PT _ (TS _ 19) }
  'Type' { PT _ (TS _ 20) }
  '[' { PT _ (TS _ 21) }
  '[:' { PT _ (TS _ 22) }
  '\\' { PT _ (TS _ 23) }
  ']' { PT _ (TS _ 24) }
  '^' { PT _ (TS _ 25) }
  '`' { PT _ (TS _ 26) }
  'as' { PT _ (TS _ 27) }
  'assert' { PT _ (TS _ 28) }
  'case' { PT _ (TS _ 29) }
  'data' { PT _ (TS _ 30) }
  'end' { PT _ (TS _ 31) }
  'fwd' { PT _ (TS _ 32) }
  'in' { PT _ (TS _ 33) }
  'let' { PT _ (TS _ 34) }
  'new' { PT _ (TS _ 35) }
  'new/' { PT _ (TS _ 36) }
  'of' { PT _ (TS _ 37) }
  'parallel' { PT _ (TS _ 38) }
  'proc' { PT _ (TS _ 39) }
  'recv' { PT _ (TS _ 40) }
  'send' { PT _ (TS _ 41) }
  'sequence' { PT _ (TS _ 42) }
  'slice' { PT _ (TS _ 43) }
  'split' { PT _ (TS _ 44) }
  'with' { PT _ (TS _ 45) }
  '{' { PT _ (TS _ 46) }
  '|' { PT _ (TS _ 47) }
  '}' { PT _ (TS _ 48) }
  '~' { PT _ (TS _ 49) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_Name { PT _ (T_Name $$) }
L_OpName { PT _ (T_OpName $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
String  :: { String }  : L_quoted {  $1 }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
Name    :: { Name} : L_Name { Name ($1)}
OpName    :: { OpName} : L_OpName { OpName ($1)}

Program :: { Program }
Program : ListDec { Ling.Fmt.Benjamin.Abs.Prg $1 }
Dec :: { Dec }
Dec : Name OptSig '=' Term { Ling.Fmt.Benjamin.Abs.DDef $1 $2 $4 }
    | Name ':' Term { Ling.Fmt.Benjamin.Abs.DSig $1 $3 }
    | 'data' Name '=' ListConName { Ling.Fmt.Benjamin.Abs.DDat $2 $4 }
    | 'assert' Assertion { Ling.Fmt.Benjamin.Abs.DAsr $2 }
Assertion :: { Assertion }
Assertion : Term '=' Term OptSig { Ling.Fmt.Benjamin.Abs.AEq $1 $3 $4 }
ConName :: { ConName }
ConName : '`' Name { Ling.Fmt.Benjamin.Abs.CN $2 }
ListConName :: { [ConName] }
ListConName : {- empty -} { [] }
            | ConName { (:[]) $1 }
            | ConName '|' ListConName { (:) $1 $3 }
OptSig :: { OptSig }
OptSig : {- empty -} { Ling.Fmt.Benjamin.Abs.NoSig }
       | ':' Term { Ling.Fmt.Benjamin.Abs.SoSig $2 }
ListDec :: { [Dec] }
ListDec : {- empty -} { [] }
        | Dec { (:[]) $1 }
        | Dec ',' ListDec { (:) $1 $3 }
VarDec :: { VarDec }
VarDec : '(' Name OptSig ')' { Ling.Fmt.Benjamin.Abs.VD $2 $3 }
ChanDec :: { ChanDec }
ChanDec : Name OptRepl OptSession { Ling.Fmt.Benjamin.Abs.CD $1 $2 $3 }
ListChanDec :: { [ChanDec] }
ListChanDec : {- empty -} { [] }
            | ChanDec { (:[]) $1 }
            | ChanDec ',' ListChanDec { (:) $1 $3 }
Branch :: { Branch }
Branch : ConName '->' Term { Ling.Fmt.Benjamin.Abs.Br $1 $3 }
ListBranch :: { [Branch] }
ListBranch : {- empty -} { [] }
           | Branch { (:[]) $1 }
           | Branch ',' ListBranch { (:) $1 $3 }
Literal :: { Literal }
Literal : Integer { Ling.Fmt.Benjamin.Abs.LInteger $1 }
        | Double { Ling.Fmt.Benjamin.Abs.LDouble $1 }
        | String { Ling.Fmt.Benjamin.Abs.LString $1 }
        | Char { Ling.Fmt.Benjamin.Abs.LChar $1 }
ATerm :: { ATerm }
ATerm : Name { Ling.Fmt.Benjamin.Abs.Var $1 }
      | OpName { Ling.Fmt.Benjamin.Abs.Op $1 }
      | Literal { Ling.Fmt.Benjamin.Abs.Lit $1 }
      | ConName { Ling.Fmt.Benjamin.Abs.Con $1 }
      | 'Type' { Ling.Fmt.Benjamin.Abs.TTyp }
      | '<' ListRSession '>' { Ling.Fmt.Benjamin.Abs.TProto $2 }
      | '(' Term OptSig ')' { Ling.Fmt.Benjamin.Abs.Paren $2 $3 }
      | 'end' { Ling.Fmt.Benjamin.Abs.End }
      | '{' ListRSession '}' { Ling.Fmt.Benjamin.Abs.Par $2 }
      | '[' ListRSession ']' { Ling.Fmt.Benjamin.Abs.Ten $2 }
      | '[:' ListRSession ':]' { Ling.Fmt.Benjamin.Abs.Seq $2 }
ListATerm :: { [ATerm] }
ListATerm : {- empty -} { [] } | ListATerm ATerm { flip (:) $1 $2 }
Term3 :: { Term }
Term3 : ATerm ListATerm { Ling.Fmt.Benjamin.Abs.RawApp $1 (reverse $2) }
Term2 :: { Term }
Term2 : 'case' Term 'of' '{' ListBranch '}' { Ling.Fmt.Benjamin.Abs.Case $2 $5 }
      | '!' Term3 CSession { Ling.Fmt.Benjamin.Abs.Snd $2 $3 }
      | '?' Term3 CSession { Ling.Fmt.Benjamin.Abs.Rcv $2 $3 }
      | '~' Term2 { Ling.Fmt.Benjamin.Abs.Dual $2 }
      | '<-' Name { Ling.Fmt.Benjamin.Abs.TRecv $2 }
      | Term3 { $1 }
Term1 :: { Term }
Term1 : Term2 '-o' Term1 { Ling.Fmt.Benjamin.Abs.Loli $1 $3 }
      | Term2 '->' Term1 { Ling.Fmt.Benjamin.Abs.TFun $1 $3 }
      | Term2 '**' Term1 { Ling.Fmt.Benjamin.Abs.TSig $1 $3 }
      | 'let' Name OptSig '=' Term 'in' Term { Ling.Fmt.Benjamin.Abs.Let $2 $3 $5 $7 }
      | Term2 { $1 }
Term :: { Term }
Term : '\\' Term2 '->' Term { Ling.Fmt.Benjamin.Abs.Lam $2 $4 }
     | 'proc' '(' ListChanDec ')' Proc { Ling.Fmt.Benjamin.Abs.TProc $3 $5 }
     | Term1 { $1 }
Proc1 :: { Proc }
Proc1 : Act { Ling.Fmt.Benjamin.Abs.PAct $1 }
      | '(' ListProc ')' { Ling.Fmt.Benjamin.Abs.PPrll $2 }
      | ReplKind '^' ATerm WithIndex Proc1 { Ling.Fmt.Benjamin.Abs.PRepl $1 $3 $4 $5 }
Proc :: { Proc }
Proc : Proc1 Proc { Ling.Fmt.Benjamin.Abs.PNxt $1 $2 }
     | Proc1 '.' Proc { Ling.Fmt.Benjamin.Abs.PDot $1 $3 }
     | Proc1 ';' Proc { Ling.Fmt.Benjamin.Abs.PSem $1 $3 }
     | 'slice' '(' ListChanDec ')' ATerm 'as' Name Proc { Ling.Fmt.Benjamin.Abs.NewSlice $3 $5 $7 $8 }
     | Proc1 { $1 }
ListProc :: { [Proc] }
ListProc : {- empty -} { [] }
         | Proc { (:[]) $1 }
         | Proc '|' ListProc { (:) $1 $3 }
ReplKind :: { ReplKind }
ReplKind : 'sequence' { Ling.Fmt.Benjamin.Abs.ReplSeq }
         | 'parallel' { Ling.Fmt.Benjamin.Abs.ReplPar }
WithIndex :: { WithIndex }
WithIndex : {- empty -} { Ling.Fmt.Benjamin.Abs.NoIndex }
          | 'with' Name { Ling.Fmt.Benjamin.Abs.SoIndex $2 }
Act :: { Act }
Act : NewAlloc { Ling.Fmt.Benjamin.Abs.Nu $1 }
    | OptSplit '{' ListChanDec '}' { Ling.Fmt.Benjamin.Abs.ParSplit $1 $3 }
    | OptSplit '[' ListChanDec ']' { Ling.Fmt.Benjamin.Abs.TenSplit $1 $3 }
    | OptSplit '[:' ListChanDec ':]' { Ling.Fmt.Benjamin.Abs.SeqSplit $1 $3 }
    | 'send' Name ATerm { Ling.Fmt.Benjamin.Abs.Send $2 $3 }
    | Name OptSession '<-' ATerm { Ling.Fmt.Benjamin.Abs.NewSend $1 $2 $4 }
    | 'recv' Name VarDec { Ling.Fmt.Benjamin.Abs.Recv $2 $3 }
    | 'let' Name OptSig '<-' Name { Ling.Fmt.Benjamin.Abs.NewRecv $2 $3 $5 }
    | 'let' Name OptSig '<=' ATerm { Ling.Fmt.Benjamin.Abs.LetRecv $2 $3 $5 }
    | 'fwd' ASession '(' ListChanDec ')' { Ling.Fmt.Benjamin.Abs.Ax $2 $4 }
    | 'fwd' Integer ASession Name { Ling.Fmt.Benjamin.Abs.SplitAx $2 $3 $4 }
    | '@' ATerm TopCPatt { Ling.Fmt.Benjamin.Abs.At $2 $3 }
    | 'let' Name OptSig '=' ATerm { Ling.Fmt.Benjamin.Abs.LetA $2 $3 $5 }
ASession :: { ASession }
ASession : ATerm { Ling.Fmt.Benjamin.Abs.AS $1 }
OptAs :: { OptAs }
OptAs : {- empty -} { Ling.Fmt.Benjamin.Abs.NoAs }
      | 'as' { Ling.Fmt.Benjamin.Abs.SoAs }
OptSplit :: { OptSplit }
OptSplit : 'split' Name OptAs { Ling.Fmt.Benjamin.Abs.SoSplit $2 $3 }
         | Name { Ling.Fmt.Benjamin.Abs.NoSplit $1 }
TopCPatt :: { TopCPatt }
TopCPatt : '(' ListChanDec ')' { Ling.Fmt.Benjamin.Abs.OldTopPatt $2 }
         | '{' ListCPatt '}' { Ling.Fmt.Benjamin.Abs.ParTopPatt $2 }
         | '[' ListCPatt ']' { Ling.Fmt.Benjamin.Abs.TenTopPatt $2 }
         | '[:' ListCPatt ':]' { Ling.Fmt.Benjamin.Abs.SeqTopPatt $2 }
CPatt :: { CPatt }
CPatt : ChanDec { Ling.Fmt.Benjamin.Abs.ChaPatt $1 }
      | '{' ListCPatt '}' { Ling.Fmt.Benjamin.Abs.ParPatt $2 }
      | '[' ListCPatt ']' { Ling.Fmt.Benjamin.Abs.TenPatt $2 }
      | '[:' ListCPatt ':]' { Ling.Fmt.Benjamin.Abs.SeqPatt $2 }
ListCPatt :: { [CPatt] }
ListCPatt : {- empty -} { [] }
          | CPatt { (:[]) $1 }
          | CPatt ',' ListCPatt { (:) $1 $3 }
OptSession :: { OptSession }
OptSession : {- empty -} { Ling.Fmt.Benjamin.Abs.NoSession }
           | ':' RSession { Ling.Fmt.Benjamin.Abs.SoSession $2 }
RSession :: { RSession }
RSession : Term OptRepl { Ling.Fmt.Benjamin.Abs.Repl $1 $2 }
ListRSession :: { [RSession] }
ListRSession : {- empty -} { [] }
             | RSession { (:[]) $1 }
             | RSession ',' ListRSession { (:) $1 $3 }
OptRepl :: { OptRepl }
OptRepl : {- empty -} { Ling.Fmt.Benjamin.Abs.One }
        | '^' ATerm { Ling.Fmt.Benjamin.Abs.Some $2 }
CSession :: { CSession }
CSession : '.' Term1 { Ling.Fmt.Benjamin.Abs.Cont $2 }
         | {- empty -} { Ling.Fmt.Benjamin.Abs.Done }
AllocTerm :: { AllocTerm }
AllocTerm : Name { Ling.Fmt.Benjamin.Abs.AVar $1 }
          | Literal { Ling.Fmt.Benjamin.Abs.ALit $1 }
          | '(' Term OptSig ')' { Ling.Fmt.Benjamin.Abs.AParen $2 $3 }
ListAllocTerm :: { [AllocTerm] }
ListAllocTerm : {- empty -} { [] }
              | ListAllocTerm AllocTerm { flip (:) $1 $2 }
NewSig :: { NewSig }
NewSig : {- empty -} { Ling.Fmt.Benjamin.Abs.NoNewSig }
       | ':*' Term { Ling.Fmt.Benjamin.Abs.NewTypeSig $2 }
       | ':' Term { Ling.Fmt.Benjamin.Abs.NewSessSig $2 }
NewPatt :: { NewPatt }
NewPatt : '[' ListCPatt ']' { Ling.Fmt.Benjamin.Abs.TenNewPatt $2 }
        | '[:' ListCPatt ':]' { Ling.Fmt.Benjamin.Abs.SeqNewPatt $2 }
        | '(' Name NewSig ')' { Ling.Fmt.Benjamin.Abs.CntNewPatt $2 $3 }
NewAlloc :: { NewAlloc }
NewAlloc : 'new' '(' ListChanDec ')' { Ling.Fmt.Benjamin.Abs.OldNew $3 }
         | 'new' NewPatt { Ling.Fmt.Benjamin.Abs.New $2 }
         | 'new/' '(' Term OptSig ')' NewPatt { Ling.Fmt.Benjamin.Abs.NewSAnn $3 $4 $6 }
         | OpName ListAllocTerm NewPatt { Ling.Fmt.Benjamin.Abs.NewNAnn $1 (reverse $2) $3 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}
